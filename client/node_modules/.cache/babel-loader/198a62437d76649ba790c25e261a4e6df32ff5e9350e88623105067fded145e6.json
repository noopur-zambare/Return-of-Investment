{"ast":null,"code":"import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport permute from './permute';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.permute = permute;\nexport default crossfilter;\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n  var data = [],\n    // the records\n    n = 0,\n    // the number of records; data.length\n    filters,\n    // 1 is filtered out\n    filterListeners = [],\n    // when the filters change\n    dataListeners = [],\n    // when data is added\n    removeDataListeners = [],\n    // when data is removed\n    callbacks = [];\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n      n1 = newData.length;\n\n    // If there's actually new data to addâ€¦\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function (l) {\n        l(newData, n0, n1);\n      });\n      triggerOnChange('dataAdded');\n    }\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var\n      // Mapping from old record indexes to new indexes (after records removed)\n      newIndex = new Array(n),\n      removed = [],\n      usePred = typeof predicate === 'function',\n      shouldRemove = function (i) {\n        return usePred ? predicate(data[i], i) : filters.zero(i);\n      };\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if (shouldRemove(index1)) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function (l) {\n      l(-1, -1, [], removed, true);\n    });\n\n    // Update indexes.\n    removeDataListeners.forEach(function (l) {\n      l(newIndex);\n    });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if (newIndex[index3] !== REMOVED_INDEX) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n  function maskForDimensions(dimensions) {\n    var n,\n      d,\n      len,\n      id,\n      mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) {\n      mask[n] = ~0;\n    }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i, mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function (d) {\n        return result(d, accessorPath);\n      };\n    }\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose,\n      // for backwards-compatibility\n      accessor: value,\n      id: function () {\n        return id;\n      }\n    };\n    var one,\n      // lowest unset bit as mask, e.g., 00001000\n      zero,\n      // inverted one, e.g., 11110111\n      offset,\n      // offset into the filters arrays\n      id,\n      // unique ID for this dimension (reused when dimensions are disposed)\n      values,\n      // sorted, cached array\n      index,\n      // maps sorted value index -> record index (in data)\n      newValues,\n      // temporary array storing newly-added values\n      newIndex,\n      // temporary array storing newly-added index\n      iterablesIndexCount,\n      iterablesIndexFilterStatus,\n      iterablesEmptyRows = [],\n      sortRange = function (n) {\n        return cr_range(n).sort(function (A, B) {\n          var a = newValues[A],\n            b = newValues[B];\n          return a < b ? -1 : a > b ? 1 : A - B;\n        });\n      },\n      refilter = xfilterFilter.filterAll,\n      // for recomputing filter\n      refilterFunction,\n      // the custom filter function in use\n      filterValue,\n      // the value used for filtering (value, array, function or undefined)\n      filterValuePresent,\n      // true if filterValue contains something\n      indexListeners = [],\n      // when data is added\n      dimensionGroups = [],\n      lo0 = 0,\n      hi0 = 0,\n      t = 0,\n      k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = offset << 7 | Math.log(one) / Math.log(2);\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n      var newIterablesIndexCount, newIterablesIndexFilterStatus;\n      if (iterable) {\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for (j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t, 1);\n        var unsortedIndex = cr_range(t);\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1]);\n          //\n          if (!k.length) {\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length;\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sortRange(t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap);\n      } else {\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sortRange(n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues),\n        lo1 = bounds[0],\n        hi1 = bounds[1];\n      var index2, index3, index4;\n      if (iterable) {\n        n1 = t;\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              if (--newIterablesIndexCount[newIndex[index2]] === 0) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n              newIterablesIndexFilterStatus[index2] = 1;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            if (--newIterablesIndexCount[newIndex[index3]] === 0) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index3] = 1;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            if (--newIterablesIndexCount[newIndex[index4]] === 0) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index4] = 1;\n          }\n        }\n      } else {\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              filters[offset][newIndex[index2] + n0] |= one;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            filters[offset][newIndex[index3] + n0] |= one;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            filters[offset][newIndex[index4] + n0] |= one;\n          }\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n      i0 = 0;\n      if (iterable) {\n        old_n0 = n0;\n        n0 = oldValues.length;\n        n1 = t;\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if (iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if (iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for (var j = 0; j + oldiiclength < n; j++) {\n          iterablesIndexCount[j + oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if (iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if (iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if (iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if (iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function (l) {\n        l(newValues, newIndex, n0, n1);\n      });\n      newValues = newIndex = null;\n    }\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n      var lo1 = bounds[0],\n        hi1 = bounds[1];\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function (d, i) {\n          return lo1 <= i && i < hi1;\n        }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n      var i,\n        j,\n        k,\n        added = [],\n        removed = [],\n        valueIndexAdded = [],\n        valueIndexRemoved = [];\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n      if (!iterable) {\n        // Flip filters normally.\n\n        for (i = 0; i < added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n        for (i = 0; i < removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++;\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if (iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--;\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if (iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if (refilter === xfilterFilter.filterAll) {\n          for (i = 0; i < iterablesEmptyRows.length; i++) {\n            if (filters[offset][k = iterablesEmptyRows[i]] & one) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for (i = 0; i < iterablesEmptyRows.length; i++) {\n            if (!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function (l) {\n        l(one, offset, added, removed);\n      });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null ? filterAll() : Array.isArray(range) ? filterRange(range) : typeof range === \"function\" ? filterFunction(range) : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n      filterIndexFunction(f, false);\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n      return dimension;\n    }\n    function filterIndexFunction(f, filterAll) {\n      var i,\n        k,\n        x,\n        added = [],\n        removed = [],\n        valueIndexAdded = [],\n        valueIndexRemoved = [],\n        indexLength = values.length;\n      if (!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);else removed.push(k);\n          }\n        }\n      }\n      if (iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n      if (!iterable) {\n        for (i = 0; i < added.length; i++) {\n          if (filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n        for (i = 0; i < removed.length; i++) {\n          if (!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if (iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++;\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if (iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if (iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--;\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if (iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if (filterAll) {\n          for (i = 0; i < iterablesEmptyRows.length; i++) {\n            if (filters[offset][k = iterablesEmptyRows[i]] & one) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for (i = 0; i < iterablesEmptyRows.length; i++) {\n            if (!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n      filterListeners.forEach(function (l) {\n        l(one, offset, added, removed);\n      });\n      triggerOnChange('filtered');\n    }\n    function currentFilter() {\n      return filterValue;\n    }\n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n        i = hi0,\n        j,\n        toSkip = 0;\n      if (top_offset && top_offset > 0) toSkip = top_offset;\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if (toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n      if (iterable) {\n        for (i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if (filters.zero(j = iterablesEmptyRows[i])) {\n            if (toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n        i,\n        j,\n        toSkip = 0;\n      if (bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n      if (iterable) {\n        // Add row with empty iterable column at the top\n        for (i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if (filters.zero(j = iterablesEmptyRows[i])) {\n            if (toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n      i = lo0;\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if (toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n      var groups,\n        // array of {key, value}\n        groupIndex,\n        // object id â†¦ group id\n        groupWidth = 8,\n        groupCapacity = capacity(groupWidth),\n        k = 0,\n        // cardinality\n        select,\n        heap,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        update = cr_null,\n        reset = cr_null,\n        resetNeeded = true,\n        groupAll = key === cr_null,\n        n0old;\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n        if (iterable) {\n          n0old = n0;\n          n0 = values.length - newValues.length;\n          n1 = newValues.length;\n        }\n        var oldGroups = groups,\n          reIndex = iterable ? [] : cr_index(k, groupCapacity),\n          add = reduceAdd,\n          remove = reduceRemove,\n          initial = reduceInitial,\n          k0 = k,\n          // old cardinality\n          i0 = 0,\n          // index of old group\n          i1 = 0,\n          // index of new record\n          j,\n          // object id\n          g0,\n          // old group\n          x0,\n          // old key\n          x1,\n          // new key\n          g,\n          // group to add\n          x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if (iterable) {\n          groupIndex = k0 ? groupIndex : [];\n        } else {\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remainâ€¦\n        while (i1 < n1) {\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {\n              key: x1,\n              value: initial()\n            }, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0);\n            if (iterable) {\n              if (groupIndex[j]) {\n                groupIndex[j].push(k);\n              } else {\n                groupIndex[j] = [k];\n              }\n            } else {\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if (iterable) {\n          for (var index1 = 0; index1 < n; index1++) {\n            if (!groupIndex[index1]) {\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if (k > i0) {\n          if (iterable) {\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          } else {\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{\n              key: null,\n              value: initial()\n            }];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if (iterable) {\n            k++;\n            return;\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n            oldGroups = groups,\n            seenGroups = cr_index(oldK, oldK),\n            i,\n            i0,\n            j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n            groupIndex = groupIndex.slice(0, j);\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable ? (reset = resetMany, update = updateMany) : k === 1 ? (reset = resetOne, update = updateOne) : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] = update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n        if (filterOne === one && filterOffset === offset || resetNeeded) return;\n        var i, j, k, n, g;\n        if (iterable) {\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if (filterOne === one && filterOffset === offset || resetNeeded) return;\n        var i,\n          k,\n          n,\n          g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i, j, g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if (iterable) {\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n          g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) {\n          return value(d.value);\n        }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null),\n        all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function () {\n        return all()[0].value;\n      };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function (group) {\n        group.dispose();\n      });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n      reduceAdd,\n      reduceRemove,\n      reduceInitial,\n      resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i, k, n;\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all() {\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n      i = 0,\n      mask = maskForDimensions(ignore_dimensions || []);\n    for (i = 0; i < n; i++) {\n      if (filters.zeroExceptMask(i, mask)) {\n        array.push(data[i]);\n      }\n    }\n    return array;\n  }\n  function onChange(cb) {\n    if (typeof cb !== 'function') {\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function () {\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n  function triggerOnChange(eventName) {\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n  return arguments.length ? add(arguments[0]) : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101 ? xfilterArray.array8 : m < 0x10001 ? xfilterArray.array16 : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\nfunction capacity(w) {\n  return w === 8 ? 0x100 : w === 16 ? 0x10000 : 0x100000000;\n}","map":{"version":3,"names":["xfilterArray","xfilterFilter","cr_identity","cr_null","cr_zero","xfilterHeapselect","xfilterHeap","bisect","permute","xfilterReduce","result","REMOVED_INDEX","crossfilter","heap","heapselect","add","remove","removeData","dimension","groupAll","size","all","allFiltered","onChange","isElementFiltered","data","n","filters","filterListeners","dataListeners","removeDataListeners","callbacks","bitarray","newData","n0","n1","length","concat","lengthen","forEach","l","triggerOnChange","predicate","newIndex","Array","removed","usePred","shouldRemove","i","zero","index1","index2","push","index3","index4","copy","truncate","maskForDimensions","dimensions","d","len","id","mask","subarrays","ignore_dimensions","zeroExceptMask","value","iterable","accessorPath","filter","filterExact","filterRange","filterFunction","filterAll","currentFilter","hasCurrentFilter","top","bottom","group","dispose","accessor","one","offset","values","index","newValues","iterablesIndexCount","iterablesIndexFilterStatus","iterablesEmptyRows","sortRange","cr_range","sort","A","B","a","b","refilter","refilterFunction","filterValue","filterValuePresent","indexListeners","dimensionGroups","lo0","hi0","t","k","unshift","preAdd","postAdd","tmp","Math","log","newIterablesIndexCount","newIterablesIndexFilterStatus","j","i0","cr_index","unsortedIndex","sortMap","map","bounds","lo1","hi1","oldValues","oldIndex","oldIterablesIndexFilterStatus","old_n0","i1","oldiiclength","arrayLengthen","index5","reIndex","slice","oldDataIndex","filterIndexBounds","filterIndexFunction","added","valueIndexAdded","valueIndexRemoved","min","max","newAdded","newRemoved","range","isArray","undefined","f","x","indexLength","top_offset","array","toSkip","bottom_offset","key","reduce","reduceCount","reduceSum","order","orderNatural","groups","groupIndex","groupWidth","groupCapacity","capacity","select","reduceAdd","reduceRemove","reduceInitial","update","reset","resetNeeded","n0old","arguments","oldGroups","initial","k0","g0","x0","x1","g","zeroExcept","groupIncrement","indexOf","updateMany","resetMany","updateOne","resetOne","arrayWiden","oldK","seenGroups","filterOne","filterOffset","notFilter","onlyExcept","reduceIncrement","reduceDecrement","reduceSubtract","by","valueOf","splice","masks","reduceValue","only","cb","console","warn","eventName","m","array8","array16","array32","w"],"sources":["/Users/noopurnishikantzambare/Downloads/ROI Website/client/node_modules/crossfilter2/src/index.js"],"sourcesContent":["import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport permute from './permute';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\n\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.permute = permute;\nexport default crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to addâ€¦\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange('dataAdded');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = new Array(n),\n        removed = [],\n        usePred = typeof predicate === 'function',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        iterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sortRange = function(n) {\n          return cr_range(n).sort(function(A, B) {\n            var a = newValues[A], b = newValues[B];\n            return a < b ? -1 : a > b ? 1 : A - B;\n          });\n        },\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n      var newIterablesIndexCount,\n          newIterablesIndexFilterStatus;\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t,1);\n        var unsortedIndex = cr_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sortRange(t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sortRange(n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n\n      var index2, index3, index4;\n      if(iterable) {\n        n1 = t;\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              if(--newIterablesIndexCount[newIndex[index2]] === 0) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n              newIterablesIndexFilterStatus[index2] = 1;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            if(--newIterablesIndexCount[newIndex[index3]] === 0) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index3] = 1;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            if(--newIterablesIndexCount[newIndex[index4]] === 0) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index4] = 1;\n          }\n        }\n      } else {\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              filters[offset][newIndex[index2] + n0] |= one;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            filters[offset][newIndex[index3] + n0] |= one;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            filters[offset][newIndex[index4] + n0] |= one;\n          }\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(refilter === xfilterFilter.filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n\n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n    }\n\n    function currentFilter() {\n      return filterValue;\n    }\n\n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id â†¦ group id\n          groupWidth = 8,\n          groupCapacity = capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = cr_null,\n          reset = cr_null,\n          resetNeeded = true,\n          groupAll = key === cr_null,\n          n0old;\n\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : cr_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remainâ€¦\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = cr_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n            groupIndex = groupIndex.slice(0, j);\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== 'function'){\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}