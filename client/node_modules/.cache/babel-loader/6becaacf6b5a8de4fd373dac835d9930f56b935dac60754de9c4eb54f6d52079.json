{"ast":null,"code":"import identity from './identity';\nimport xFilterHeap from './heap';\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n      min,\n      i,\n      d;\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n    return queue;\n  }\n  return heapselect;\n}\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;","map":{"version":3,"names":["identity","xFilterHeap","heapselect_by","f","heap","by","heapselect","a","lo","hi","k","queue","Array","Math","min","i","d","h"],"sources":["/Users/noopurnishikantzambare/Downloads/ROI Website/client/node_modules/crossfilter2/src/heapselect.js"],"sourcesContent":["import identity from './identity';\nimport xFilterHeap from './heap';\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\n\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,YAAY;AACjC,OAAOC,WAAW,MAAM,QAAQ;AAEhC,SAASC,aAAaA,CAACC,CAAC,EAAE;EACxB,IAAIC,IAAI,GAAGH,WAAW,CAACI,EAAE,CAACF,CAAC,CAAC;;EAE5B;EACA;EACA;EACA;EACA,SAASG,UAAUA,CAACC,CAAC,EAAEC,EAAE,EAAEC,EAAE,EAAEC,CAAC,EAAE;IAChC,IAAIC,KAAK,GAAG,IAAIC,KAAK,CAACF,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACL,EAAE,GAAGD,EAAE,EAAEE,CAAC,CAAC,CAAC;MAC3CI,GAAG;MACHC,CAAC;MACDC,CAAC;IAEL,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,EAAE,EAAEK,CAAC,EAAEJ,KAAK,CAACI,CAAC,CAAC,GAAGR,CAAC,CAACC,EAAE,EAAE,CAAC;IAC1CJ,IAAI,CAACO,KAAK,EAAE,CAAC,EAAED,CAAC,CAAC;IAEjB,IAAIF,EAAE,GAAGC,EAAE,EAAE;MACXK,GAAG,GAAGX,CAAC,CAACQ,KAAK,CAAC,CAAC,CAAC,CAAC;MACjB,GAAG;QACD,IAAIR,CAAC,CAACa,CAAC,GAAGT,CAAC,CAACC,EAAE,CAAC,CAAC,GAAGM,GAAG,EAAE;UACtBH,KAAK,CAAC,CAAC,CAAC,GAAGK,CAAC;UACZF,GAAG,GAAGX,CAAC,CAACC,IAAI,CAACO,KAAK,EAAE,CAAC,EAAED,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/B;MACF,CAAC,QAAQ,EAAEF,EAAE,GAAGC,EAAE;IACpB;IAEA,OAAOE,KAAK;EACd;EAEA,OAAOL,UAAU;AACnB;AAGA,MAAMW,CAAC,GAAGf,aAAa,CAACF,QAAQ,CAAC;AACjCiB,CAAC,CAACZ,EAAE,GAAGH,aAAa,CAAC,CAAC;;AAEtB,eAAee,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}